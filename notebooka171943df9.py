# -*- coding: utf-8 -*-
"""notebooka171943df9

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/notebooka171943df9-61edd352-9b46-4544-9af8-7334d44dea00.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240527/auto/storage/goog4_request%26X-Goog-Date%3D20240527T102240Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D98ceb4b3fe2f4c7964948fee60e0931b8a5c43d95ac29292c611df9bf80767892dd090fec1e67deeffc1e3487dc30442cb6007e94a418695b0d4bc8c9b9adb8f31c8ebaa372f2c125e2ed428a1388cb97ea5175568006dd744d198eddfbff8c5539d971c7070796e364dadee1b58ac9e0f512b7b613852f5d0ae652dd5e7940bc0e136e3d662af7b7a2ec4815239b0a80a4cf7b3124d02ae2ad4117f240e353946e976b07273819131d7ecb210a92174b03f2f4efcd1a617aca8ecc46f62ebf521eb04d54d3c32cd02e4d653a94daad7b3e29244491281d7f12cbbad38c51f288741e3150654c5c9425275c7b3d7a5604652d2ff18bec475acab7f610876086e

# The Nussinov-Jacobson algorithm explored

This exploration was suggested by the
[Stanford Ribonanza RNA Folding](https://www.kaggle.com/competitions/stanford-ribonanza-rna-folding/overview)
competition.

The Nussinov-Jacobson algorithm is taken from a classic paper
that describes the application of dynamic programming
to determining the most likely folding of an RNA sequence,
that is to say,
the energetically most favourable.

It produces quite poor results.
However, several more recent algorithms are
refinements of the same technique,
with more parameters,
so it repays study.

Ref: Nussinov, R; Jacobson, A B.
[Fast algorithm for predicting the secondary structure of single-stranded RNA.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC350273)
Proceedings of the National Academy of Sciences of the United States of America.
77 (11): 6309â€“6313, Nov 1980 Biochemistry.
"""

# Install/import dependencies for our own implementation.

from typing import Callable
import numpy as np
from draw_rna import ipynb_draw

"""## Implementation

The first explanation in Nussinov and Jacobson's paper is an algorithm that simply *maximises* the number of allowable pairs.
The paper then describes an extension in which free energy is *minimised*.
This extension allows each base-pairing a different energy
and includes a parameter that determines a minimum loop size,
by requiring that we pair only those bases more than a certain distance apart.

We implement the second, but can reduce it to the original by assigning all
allowable pairings an energy of -1,
and setting the loop size constraint to zero (resulting in much adjacent pairing).
"""

def base_as_int(c: str) -> int:
    """Map one character from bases ACGU to an int 0..3"""
    return "ACGU".find(c)


def int_as_base(i: int) -> str:
    """Map int bases 0..3 to a character from ACGU"""
    return "ACGU"[i]


class RNASolution:
    def __init__(self, N: int):
        self.N = N
        self._M = np.zeros((N, N), dtype=np.int16)
        self._K = np.zeros((N, N), dtype=np.int16)
        for i in range(N):
            self._K[i, i] = -1

    def getM(self, i, j) -> int:
        return self._M[i, j]

    def getK(self, i, j) -> int:
        return self._K[i, j]

    def putKM(self, i: int, j: int, k: int, m: int):
        self._K[i, j] = k
        self._M[i, j] = m

    def walk_range(self, a: int, b: int):
        """Walk the range [a,b-1] inclusive."""
        # We walk a leftmost depth first recursion
        # print(f"walk_range({a}, {b})")
        assert 0 <= a < self.N
        assert a < b <= self.N
        # Last base in range
        if (q := b - 1) == a:
            # There is one (unbound) base in the range
            assert self.getK(a, q) < 0
            # print(f"{q} is unbound")
            yield q, -1
        elif (p := self.getK(a, q)) >= 0:
            # q pairs with p
            # print(f"{q} pairs with {p}")
            if p > a:
                yield from self.walk_range(a, p)
            yield p, q
            p += 1
            if q > p:
                yield from self.walk_range(p, q)
        else:
            # Rightmost base q is unbound
            # print(f"{q} is unbound")
            assert q > a
            yield from self.walk_range(a, q)
            yield q, -1

    def walk(self):
        """Walk the table generating bound and unbound bases."""
        # We walk a leftmost depth first recursion
        for a, b in self.walk_range(0, self.N):
            if b < 0:
                print(a)
            else:
                print(f"{a}-{b}")

    def as_dots(self):
        """Dot-bracket form of the fold"""
        D, L, R = '.()'
        dots = [''] * self.N
        for a, b in self.walk_range(0, self.N):
            if b < 0:
                dots[a] = D
            else:
                dots[a] = L
                dots[b] = R
        return ''.join(dots)


WeightFunction = Callable[[int, int], int]



class RNAFolder:
    """An RNA folding algorithm and parameters

    An instance holds all the configuration necessary to
    solve an RNA folding problem. Note that energies are
    the free-energy (a more negative value for the more
    favourable pairings).
    """
    DEFAULT_ENERGIES = dict(
        BPFE_AU = -2.0,
        BPFE_CG = -3.0,
        BPFE_GU = -1.0,
        BPFE_DEFAULT = 10.0
    )

    def __init__(self, loop_min = 3, energies=None):
        self.lmin = loop_min
        if energies is None:
            energies = self.DEFAULT_ENERGIES
        self._bpfe = self._free_energy_lookup(energies)

    @staticmethod
    # create a lookup table (a 4x4 numpy array) for the free energy values associated with different RNA base pairs. This table facilitates quick access to the free energy values based on integer representations of the RNA bases (A, C, G, U).
    def _free_energy_lookup(lookup: dict, dflt=None):
        """Create look-up from base-pair (ints) to free energy"""
        a = np.zeros((4, 4), dtype=np.int32)
        if dflt is None:
            dflt = lookup.get("BPFE_DEFAULT", 0.0)
        for i in range(4):
            bi = int_as_base(i)
            a[i, i] = lookup.get(f"BPFE_{bi}{bi}", dflt)
            for j in range(i + 1, 4):
                bj = int_as_base(j)
                a[i, j] = a[j, i] = lookup.get(f"BPFE_{bi}{bj}", dflt)
        return a

    #eturns a lambda function that takes two indices (i and j) and returns the free energy of pairing the bases at these positions.
    def get_weight_function(self, rna: str) -> WeightFunction:
        _rna = np.fromiter(map(base_as_int, rna.upper()),
                           dtype=np.int8, count=len(rna))
        return lambda i, j: self._bpfe[_rna[i], _rna[j]]

    def solve(self, rna: str, w: WeightFunction = None):
        # Nussinov, Jacobson. Fast algorithm for predicting the secondary
        # structure of single-stranded RNA. Proc. Natl. Acad. Sci. USA
        # Vol. 77, No. 11, pp. 6309-6313, Nov 1980 Biochemistry.
        
        # If w is given, we only use rna via its length
        N = len(rna)

        if w is None:
            w = self.get_weight_function(rna)

        sol_n = RNASolution(N)
        M = sol_n.getM

        for p in range(1, N):
            # in pass p, (i,j) moves diagonally down and to the right
            # p elements above the main diagonal.
            for i in range(N - p):
                # Fill M[i, j] with max score for interval [i,j] incl.
                j = i + p
                # First hypothesis is (i,j) do not pair:
                # score for [i:j]  will be that for i:j-1
                m = M(i, j - 1) 
                km = -1
                for k in range(i, j - self.lmin):
                    # score the split [i,k-1], [k+1,j] in which the pair
                    # (k,j) is formed. We keep the k with lowest m1.
                    s = M(i, k - 1) + M(k + 1, j - 1) + w(k, j)
                    if s < m: # TDL: change to max instead of min
                        m, km = s, k
                sol_n.putKM(i, j, km, m)
        return sol_n

"""Internally we represent the bases ACGU by integers 0..3
so that free energies may be expressed in a 4x4 table
and quickly looked up.
"""

RNAFolder()._bpfe

"""We want to know first of all that we have implemented the algorithm correctly.

As a check, we reproduce the worked example in the paper.
Since we implemented the free-energy version of the algorithm,
and since we index from 0 not 1,
we have to adjust the internal representation at presentation time to match Nussinov's.
"""

def test_nussinov(rna: str = "GGCAGUACCAAGUCGCGAAAGCGAUGGCCUUGCAAAGGGUAUGGUAAUAAGCUGCC"):
    """Reproduce the worked example in the classic paper

    This function creates an RNAFolder using a single energy -1.0 for
    CG bonds as in the paper at reference, and uses it to
    fold the RNA string given as argument. The default rna argument
    is the example used in the paper.

    Ref: Nussinov, Jacobson. Fast algorithm for predicting the secondary
    structure of single-stranded RNA. Proc. Natl. Acad. Sci. USA
    Vol. 77, No. 11, pp. 6309-6313, Nov 1980 Biochemistry.
    """
    # Paper maximises bond counts rather than minimises energy.
    # Set allowed bond free energy to -1 so the most bonds wins.
    ENERGIES = {k: -1 for k in ('BPFE_AU', 'BPFE_CG', 'BPFE_GU')}
    f = RNAFolder(energies=ENERGIES)
    s = f.solve(rna)
    N = s.N

    # Tabulate the scores as in Nussinov (who uses 1-up indexing)
    print('     ' + ''.join(f"{j+1:3d}" for j in range(N)))
    print('     ' + ' --' * N)
    for i in range(N):
        print(f"{i+1:3d} :", end='')
        for j in range(N):
            if j < i:
                # Display in paper has M transposed and as a count
                print(f"{-int(s.getM(j, i)):3d}", end='')
            elif j > i:
                # Paper uses 1-up indexes in K
                print(f"{s.getK(i, j) + 1:3d}", end='')
            else:
                print(f" ={rna[i]}", end='')
        print()

test_nussinov()

"""The `RNASolution` object is able to walk the K-matrix (see paper), which is the the upper-right half in the display above.
By careful ordering of the walk, we can keep the results in 5' to 3' base order.
"""

def test_walk(rna: str = "GGCAGUACCAAGUCGCGAAAGCGAUGGCCUUGCAAAGGGUAUGGUAAUAAGCUGCC"):
    """Walk the folds of the worked example in the classic paper

    Repeat test_nussinov(rna) walking the table to report the structure.
    """
    # Paper uses bond counts rather than energy
    ENERGIES = {k: -1 for k in ('BPFE_AU', 'BPFE_CG', 'BPFE_GU')}
    f = RNAFolder(energies=ENERGIES,loop_min=3)
    s = f.solve(rna)
    # Walk the table as in Nussinov
    for a, b in s.walk_range(0, s.N):
        if b < 0:
            print(a)
        else:
            print(f"{a}-{b}")

test_walk()

"""The same walk allows us to generate a dot-bracket notation for the fold."""

def test_dots(rna: str = "GGCAGUACCAAGUCGCGAAAGCGAUGGCCUUGCAAAGGGUAUGGUAAUAAGCUGCC", loop_min=3):
    """Walk the folds generating dot-bracket string.
    """
    # Paper uses counts rather than energy
    ENERGIES = {k: -1 for k in ('BPFE_AU', 'BPFE_CG', 'BPFE_GU')}
    f = RNAFolder(energies=ENERGIES, loop_min=3)
    s = f.solve(rna)
    print(s.as_dots())

test_dots()

"""## Application to some real RNA

In the next result we compare our result
and the reference answer
(possibly not verified experimentally but more plausible)
from RNA Central.
We work with
[Felis catus (domestic cat) tRNA](https://rnacentral.org/rna/URS0000BE3C4E/9685).
"""

def test_cat():
    tRNA_Cat, tRNA_Cat_ref = (
        "GGCAGUACCAAGUCGCGAAAGCGAUGGCCUUGCAAAGGGUAUGGUAAUAAGCUGCC",
        "(((((((((((((((((....)).))))(((....))).).))))).)....))))")

    # Free energies (-ve is favourable)
    ENERGIES = {k: -1 for k in ('BPFE_AU', 'BPFE_CG', 'BPFE_GU')}


    # Compute a structure
    f = RNAFolder(energies=ENERGIES, loop_min=3)
    s = f.solve(tRNA_Cat)
    structure = s.as_dots()

    print(tRNA_Cat)
    print(tRNA_Cat_ref)
    print(structure)

    # Draw using draw_rna
    ipynb_draw.draw_struct(tRNA_Cat, structure)
    ipynb_draw.draw_struct(tRNA_Cat, tRNA_Cat_ref)

test_cat()

"""We probably shouldn't expect this to work well,
and it doesn't.
It is worth thinking about why.

When we compare the results of the simple version
with RNA Central's structure,
we see that
ours favours long straggly helices with bulges,
where the reference structure has spacious loops.
There is no reason in the simple Nussinov score
not to pair bases that face each other across those loops,
and it will since each time it makes the energy a little lower.

In the reference structure,
C bases face G bases and A faces U across a hairpin or internal loop without it collapsing.
There must be an energetic motive for that.

We can also spot one place where the reference pairs A-C.
We're never going to come up with that. (Can it be right?)

The more sophisticated models refer to energy penalties for
bulges and imbalances in internal loops.
And there is a penalty for an isolated pair,
as our algorithm might form across a loop.
However, Vicens and Kieft ([how to think...](https://www.pnas.org/doi/10.1073/pnas.2112677119))
make the point that interactions do occur within these loops,
so there may be a sort of "loop energy" to estimate,
short of an actual pair.

"""